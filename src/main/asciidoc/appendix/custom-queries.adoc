[[custom-queries]]
= Custom queries

Spring Data Neo4j, like all the other Spring Data modules, allows you to specify custom queries in you repositories.
Those come in handy if you cannot express the finder logic via derived query functions.

Because Spring Data Neo4j works heavily record-oriented under the hood, it is important to keep this in mind and not build up a result set with multiple records for the same "root node".

TIP: Please have a look in the FAQ as well to learn about alternative forms of using custom queries from repositories, especially
how to use custom queries with custom mappings: <<faq.custom-queries-and-custom-mappings>>.

[[custom-queries.for-relationships]]
== Queries with relationships

[[custom-queries.for-relationships.cartesian-product]]
=== Beware of the cartesian product

Assuming you have a query like `MATCH (m:Movie{title: 'The Matrix'})<-[r:ACTED_IN]-(p:Person) return m,r,p` that results into something like this:

.Multiple records (shortened)
----
+------------------------------------------------------------------------------------------+
| m        | r                                    | p                                      |
+------------------------------------------------------------------------------------------+
| (:Movie) | [:ACTED_IN {roles: ["Emil"]}]        | (:Person {name: "Emil Eifrem"})        |
| (:Movie) | [:ACTED_IN {roles: ["Agent Smith"]}] | (:Person {name: "Hugo Weaving})        |
| (:Movie) | [:ACTED_IN {roles: ["Morpheus"]}]    | (:Person {name: "Laurence Fishburne"}) |
| (:Movie) | [:ACTED_IN {roles: ["Trinity"]}]     | (:Person {name: "Carrie-Anne Moss"})   |
| (:Movie) | [:ACTED_IN {roles: ["Neo"]}]         | (:Person {name: "Keanu Reeves"})       |
+------------------------------------------------------------------------------------------+
----

The result from the mapping would be most likely unusable.
If this would get mapped into a list, it will contain duplicates for the `Movie` but this movie will only have one relationship.

[[custom-queries.for-relationships.one.record]]
=== Getting one record per root node

To get the right object(s) back, it is required to _collect_ the relationships and related nodes in the query: `MATCH (m:Movie{title: 'The Matrix'})<-[r:ACTED_IN]-(p:Person) return m,collect(r),collect(p)`

.Single record (shortended)
----
+------------------------------------------------------------------------+
| m        | collect(r)                     | collect(p)                 |
+------------------------------------------------------------------------+
| (:Movie) | [[:ACTED_IN], [:ACTED_IN], ...]| [(:Person), (:Person),...] |
+------------------------------------------------------------------------+
----

With this result as a single record it is possible for Spring Data Neo4j to add all related nodes correctly to the root node.

[[custom-queries.for-relationships.long-paths]]
=== Reaching deeper into the graph

The example above assumes that you are only trying to fetch the first level of related nodes.
This is sometimes not enough and there are maybe nodes deeper in the graph that should also be part of the mapped instance.
There are two ways to achieve this: Database-side or client-side reduction.

For this the example from above should also contain `Movies` on the `Persons` that get returned with the initial `Movie`.

.Example for 'The Matrix' and 'Keanu Reeves'
image::movie-graph-deep.png[]

[[custom-queries.for-relationships.long-paths.database]]
==== Database-side reduction

Keeping in mind that Spring Data Neo4j can only properly process record based, the result for one entity instance needs to be in one record.
Using https://neo4j.com/docs/cypher-manual/current/syntax/patterns/#cypher-pattern-path-variables[Cypher's path] capabilities is a valid option to fetch all branches in the graph.

[source,cypher]
.Naive path-based approach
----
MATCH p=(m:Movie{title: 'The Matrix'})<-[:ACTED_IN]-(:Person)-[:ACTED_IN*..0]->(:Movie)
RETURN p;
----

This will result in multiple paths that are not merged within one record.
It is possible to call `collect(p)` but Spring Data Neo4j does not understand the concept of paths in the mapping process.
Thus, nodes and relationships needs to get extracted for the result.

[source,cypher]
.Extracting nodes and relationships
----
MATCH p=(m:Movie{title: 'The Matrix'})<-[:ACTED_IN]-(:Person)-[:ACTED_IN*..0]->(:Movie)
RETURN m, nodes(p), relationships(p);
----

Because there are multiple paths that lead from 'The Matrix' to another movie, the result still won't be a single record.
This is where https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-reduce[Cypher's reduce function] comes into play.

[source,cypher]
.Reducing nodes and relationships
----
MATCH p=(m:Movie{title: 'The Matrix'})<-[:ACTED_IN]-(:Person)-[:ACTED_IN*..0]->(:Movie)
WITH collect(p) as paths, m
WITH m,
reduce(a=[], node in reduce(b=[], c in [aa in paths | nodes(aa)] | b + c) | case when node in a then a else a + node end) as nodes,
reduce(d=[], relationship in reduce(e=[], f in [dd in paths | relationships(dd)] | e + f) | case when relationship in d then d else d + relationship end) as relationships
RETURN m, relationships, nodes;
----

The `reduce` function allows us to flatten the nodes and relationships from various paths.
As a result we will get a tuple similar to <<custom-queries.for-relationships.one.record>> but with a mixture of relationship types or nodes in the collections.

[[custom-queries.for-relationships.long-paths.client]]
==== Client-side reduction

If the reduction should happen on the client-side, Spring Data Neo4j enables you to map also lists of lists of relationships or nodes.
Still, the requirement applies that the returned record should contain all information to hydrate the resulting entity instance correctly.

[source,cypher]
.Collect nodes and relationships from path
----
MATCH p=(m:Movie{title: 'The Matrix'})<-[:ACTED_IN]-(:Person)-[:ACTED_IN*..0]->(:Movie)
RETURN m, collect(nodes(p)), collect(relationships(p));
----

The additional `collect` statement creates lists in the format:
----
[[rel1, rel2], [rel3, rel4]]
----
Those lists will now get converted during the mapping process into a flat list.

NOTE: Deciding if you want to go with client-side or database-side reduction depends on the amount of data that will get generated.
All the paths needs to get created in the database's memory first when the `reduce` function is used.
On the other hand a large amount of data that needs to get merged on the client-side results in a higher memory usage there.

[[custom-queries.parameters]]
== Parameters in custom queries

You do this exactly the same way as in a standard Cypher query issued in the Neo4j Browser or the Cypher-Shell,
with the `$` syntax (from Neo4j 4.0 on upwards, the old `{foo}` syntax for Cypher parameters has been removed from the database).

[source,java,indent=0]
.ARepository.java
----
include::../../../../src/test/java/org/springframework/data/neo4j/documentation/repositories/domain_events/ARepository.java[tags=standard-parameter]
----
<.> Here we are referring to the parameter by its name.
You can also use `$0` etc. instead.

NOTE: You need to compile your Java 8+ project with `-parameters` to make named parameters work without further annotations.
The Spring Boot Maven and Gradle plugins do this automatically for you.
If this is not feasible for any reason, you can either add
`@Param`  and specify the name explicitly or use the parameters index.

[[custom-queries.spel]]
== Spring Expression Language in custom queries

{spring-framework-ref}/core.html#expressions[Spring Expression Language (SpEL)] can be used in custom queries inside `:#{}`.
This is the standard Spring Data way of defining a block of text inside a query that undergoes SpEL evaluation.

The following example basically defines the same query as above, but uses a `WHERE` clause to avoid even more curly braces:

[source,java,indent=0]
[[custom-queries-with-spel-parameter-example]]
.ARepository.java
----
include::../../../../src/test/java/org/springframework/data/neo4j/documentation/repositories/domain_events/ARepository.java[tags=spel]
----

The SpEL blocked starts with `:#{` and than refers to the given `String` parameters by name (`#pt1`).
Don't confuse this with the above Cypher syntax!
The SpEL expression concatenates both parameters into one single value that is eventually passed on to the <<neo4j-client>>.
The SpEL block ends with `}`.

SpEL also solves two additional problems. We provide two extensions that allow to pass in a `Sort` object into custom queries.
Remember <<custom-queries-with-page-and-slice-examples>> from <<faq.custom-queries-with-page-and-slice,custom queries>>?
With the `orderBy` extension you can pass in a `Pageable` with a dynamic sort to a custom query:

[[custom-queries.spel.source]]
[source,java]
.orderBy-Extension
----
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.neo4j.repository.Neo4jRepository;
import org.springframework.data.neo4j.repository.query.Query;

public interface MyPersonRepository extends Neo4jRepository<Person, Long> {

    @Query(""
        + "MATCH (n:Person) WHERE n.name = $name RETURN n "
        + ":#{orderBy(#pageable)} SKIP $skip LIMIT $limit" // <.>
    )
    Slice<Person> findSliceByName(String name, Pageable pageable);

    @Query(""
        + "MATCH (n:Person) WHERE n.name = $name RETURN n :#{orderBy(#sort)}" // <.>
    )
    List<Person> findAllByName(String name, Sort sort);
}
----
<.> A `Pageable` has always the name `pageable` inside the SpEL context.
<.> A `Sort` has always the name `sort` inside the SpEL context.

The `literal` extension can be used to make things like labels or relationship-types "dynamic" in custom queries.
Neither labels nor relationship types can be parameterized in Cypher, so they must be given literal.

[source,java]
.literal-Extension
----
interface BaseClassRepository extends Neo4jRepository<Inheritance.BaseClass, Long> {

    @Query("MATCH (n:`:#{literal(#label)}`) RETURN n") // <.>
    List<Inheritance.BaseClass> findByLabel(String label);
}
----
<.> The `literal` extension will be replaced with the literal value of the evaluated parameter.

Here, the `literal` value has been used to match dynamically on a Label.
If you pass in `SomeLabel` as a parameter to the method, `MATCH (n:``SomeLabel``) RETURN n`
will be generated. Ticks have been added to correctly escape values. SDN won't do this
for you as this is probably not what you want in all cases.
